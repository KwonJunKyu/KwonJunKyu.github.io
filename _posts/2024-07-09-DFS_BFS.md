---
layout: single
title: "알고리즘 - DFS와 BFS"
categories: Algorithm
tags: [C++]
typora-root-url: ../
---



## DFS (Depth First Search : 깊이 우선 탐색)

#### 끝까지 탐색하는 알고리즘

<img src="/images/2024-07-09-DFS_BFS/끝까지 간다.webp" alt="끝까지 간다" style="zoom:25%;" />

이 알고리즘은 그래프에서 `모든 노드`를 방문하고자 하는 경우에 사용한다. 임의의 노드에서 시작해서 다음 분기로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방식이다. Stack 자료형을 이용하여 구현한다.

#### 작동 방식

- 시작 노드 정보를 스택에 삽입하고 방문 처리한다.
- Stack이 빌 때까지 아래 내용을 반복한다.
  - Stack에 맨 위 있는 노드와 이어진 노드 중 방문하지 않은 노드가 있을 경우 스택에 삽입, 방문 처리한다.
    - 이때 방문하지 않은 노드가 없을 경우 스택을 pop한다.

![DFS](/images/2024-07-09-DFS_BFS/DFS.jpg)

위 사진을 보면 그래프의 맨 끝까지 탐색한 후에 이전 노드로 돌아오며 탐색을 해나가는 것을 볼 수 있다. 여기서 1에서 2, 3, 4 중 어디로 갈지는 임의로 설정하면 된다. 필자는 대부분 프로그래밍 문제를 풀 때 입력되는 간선 정보 순으로 하는 편이다.

------



## BFS (Breadth First Search : 너비 우선 탐색)

#### 문어발식 운영

![분수 BFS 예시](/images/2024-07-09-DFS_BFS/분수 BFS 예시.webp)

BFS는 가장 가까운 노드부터 탐색해나가는 알고리즘이다. 근처 노드부터 차근차근 조회하므로 최적해를 찾는 데에 유리하다. 예를 들어 미로를 탐색하는 경우 DFS를 이용하면 올바른 경로를 찾을 순 있지만 최적해는 아닐 수 있다. 하지만 BFS의 경우 최종 답안이 최적해임을 보장한다. Queue 자료구조를 이용한다.

#### 미로 예시

![KakaoTalk_20240710_110756289](/images/2024-07-09-DFS_BFS/KakaoTalk_20240710_110756289.jpg)

탐색이 끝나는 시점이 'END를 만날 경우'라고 할 경우 DFS와 BFS는 위와 같이 다른 답안을 낼 수 있다. 물론 탐색의 기준을 어떻게 잡느냐에 따라 DFS의 답이 달라질 수 있으나, 가장 비효율적인 답안을 낼 수 있음을 나타내기 위해 위와 같이 표현하였다. DFS는 이어진 곳이 있다면 계속해서 파고 들어가서 답안이 보이면 중단하는 반면, BFS는 한 차례씩 순차적으로 탐색하게 되므로 최적해를 구할 수 있다.

#### 작동 방식

- 시작 노드 정보를 Queue에 넣고 방문 처리한다.
- Queue가 빌 떄까지 아래 내용을 반복한다.
  - Queue의 맨 앞 요소(front)와 인접한 요소들 중 방문 처리되지 않은 노드를 Queue에 넣고 방문 처리한다.
  - Queue를 pop한다. (DFS와 달리 따로 조건이 없이 pop한다)

![KakaoTalk_20240710_110756289_01](/images/2024-07-09-DFS_BFS/KakaoTalk_20240710_110756289_01.jpg)

위 사진은 앞선 DFS와 같은 그래프를 BFS로 탐색한 방법이다. 분수를 연상시키듯 차례로 하나씩 탐색되는 모습을 볼 수 있다.